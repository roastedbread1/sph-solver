#version 460 core

layout(local_size_x = 128) in;

struct Particle
{
	vec3 position;
	vec3 velocity;
	vec3 force;

	float density;
	float pressure;


};

layout(std430, binding = 0) buffer ParticleBuffer
{
	Particle particles[];
};

layout(std430, binding = 1) buffer MatrixBuffer 
{
	mat4 matrices[];
};

uniform float particleSeperation;
uniform int particleCubeWidth;
uniform float h;

uint hash(uint x)
{
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

float random (uint seed)
{
	return (hash(seed)) / 4294967295.0;
}

void main()
{
	uint index = gl_GlobalInvocationID.x;
	if(index >= particles.length()) return;

	int x = int(index % particleCubeWidth);
	int y = int(index / particleCubeWidth) * particleCubeWidth;
	int z = int(index / (particleCubeWidth * particleCubeWidth));

	float ranX = (random(index * 1) * 2.0 - 1.0) * h/10.0;
    float ranY = (random(index * 2) * 2.0 - 1.0) * h/10.0;
    float ranZ = (random(index * 3) * 2.0 - 1.0) * h/10.0;


	vec3 position = vec3(
        x * particleSeperation + ranX - 1.5,	
        y * particleSeperation + ranY + h + 0.1,
        z * particleSeperation + ranZ - 1.5
    );


	particles[index].position = position;
    particles[index].velocity = vec3(0.0);
    particles[index].force = vec3(0.0);
    particles[index].density = 0.0;
    particles[index].pressure = 0.0;


	    matrices[index] = mat4(
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        position.x, position.y, position.z, 1.0
        );
}